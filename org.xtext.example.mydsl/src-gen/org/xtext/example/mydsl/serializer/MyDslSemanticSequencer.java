/*
 * generated by Xtext 2.21.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import musicSheetDsl.Accidental;
import musicSheetDsl.Articulation;
import musicSheetDsl.Bracket;
import musicSheetDsl.Clef;
import musicSheetDsl.Composition;
import musicSheetDsl.MusicSheetDslPackage;
import musicSheetDsl.Note;
import musicSheetDsl.Ornament;
import musicSheetDsl.Repetition;
import musicSheetDsl.Rest;
import musicSheetDsl.Staff;
import musicSheetDsl.TimeSignature;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MusicSheetDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MusicSheetDslPackage.ACCIDENTAL:
				sequence_Accidental(context, (Accidental) semanticObject); 
				return; 
			case MusicSheetDslPackage.ARTICULATION:
				sequence_Articulation(context, (Articulation) semanticObject); 
				return; 
			case MusicSheetDslPackage.BRACKET:
				sequence_Bracket(context, (Bracket) semanticObject); 
				return; 
			case MusicSheetDslPackage.CLEF:
				sequence_Clef(context, (Clef) semanticObject); 
				return; 
			case MusicSheetDslPackage.COMPOSITION:
				sequence_Composition(context, (Composition) semanticObject); 
				return; 
			case MusicSheetDslPackage.NOTE:
				sequence_Note(context, (Note) semanticObject); 
				return; 
			case MusicSheetDslPackage.ORNAMENT:
				sequence_Ornament(context, (Ornament) semanticObject); 
				return; 
			case MusicSheetDslPackage.REPETITION:
				sequence_Repetition(context, (Repetition) semanticObject); 
				return; 
			case MusicSheetDslPackage.REST:
				sequence_Rest(context, (Rest) semanticObject); 
				return; 
			case MusicSheetDslPackage.STAFF:
				sequence_Staff(context, (Staff) semanticObject); 
				return; 
			case MusicSheetDslPackage.TIME_SIGNATURE:
				sequence_TimeSignature(context, (TimeSignature) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     StaffElement returns Accidental
	 *     Accidental returns Accidental
	 *
	 * Constraint:
	 *     (type=AccidentalType? position=EInt)
	 */
	protected void sequence_Accidental(ISerializationContext context, Accidental semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Articulation returns Articulation
	 *
	 * Constraint:
	 *     type=ArticulationType?
	 */
	protected void sequence_Articulation(ISerializationContext context, Articulation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Bracket returns Bracket
	 *
	 * Constraint:
	 *     (type=BracketType? staves+=Staff staves+=Staff*)
	 */
	protected void sequence_Bracket(ISerializationContext context, Bracket semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clef returns Clef
	 *
	 * Constraint:
	 *     type=ClefType?
	 */
	protected void sequence_Clef(ISerializationContext context, Clef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Composition returns Composition
	 *
	 * Constraint:
	 *     (
	 *         name=EString? 
	 *         author=EString? 
	 *         instrument=EString? 
	 *         tonality=EString? 
	 *         soundTempo=EInt? 
	 *         (bracket+=Bracket bracket+=Bracket*)? 
	 *         (staff+=Staff staff+=Staff*)?
	 *     )
	 */
	protected void sequence_Composition(ISerializationContext context, Composition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StaffElement returns Note
	 *     Note returns Note
	 *
	 * Constraint:
	 *     (
	 *         name=NoteName 
	 *         lyrics=EString? 
	 *         duration=NoteDuration? 
	 *         position=EInt? 
	 *         dynamic=EString? 
	 *         ornament=Ornament? 
	 *         accidental=Accidental? 
	 *         articulation=Articulation? 
	 *         fermata?='fermata'? 
	 *         dot?='dot'?
	 *     )
	 */
	protected void sequence_Note(ISerializationContext context, Note semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Ornament returns Ornament
	 *
	 * Constraint:
	 *     type=OrnamentType?
	 */
	protected void sequence_Ornament(ISerializationContext context, Ornament semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StaffElement returns Repetition
	 *     Repetition returns Repetition
	 *
	 * Constraint:
	 *     type=RepetitionType?
	 */
	protected void sequence_Repetition(ISerializationContext context, Repetition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StaffElement returns Rest
	 *     Rest returns Rest
	 *
	 * Constraint:
	 *     type=RestType?
	 */
	protected void sequence_Rest(ISerializationContext context, Rest semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Staff returns Staff
	 *
	 * Constraint:
	 *     (number=EInt clef=Clef time=TimeSignature elements+=StaffElement elements+=StaffElement*)
	 */
	protected void sequence_Staff(ISerializationContext context, Staff semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TimeSignature returns TimeSignature
	 *
	 * Constraint:
	 *     (beat=EInt beatType=EInt)
	 */
	protected void sequence_TimeSignature(ISerializationContext context, TimeSignature semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MusicSheetDslPackage.Literals.TIME_SIGNATURE__BEAT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MusicSheetDslPackage.Literals.TIME_SIGNATURE__BEAT));
			if (transientValues.isValueTransient(semanticObject, MusicSheetDslPackage.Literals.TIME_SIGNATURE__BEAT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MusicSheetDslPackage.Literals.TIME_SIGNATURE__BEAT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeSignatureAccess().getBeatEIntParserRuleCall_1_0(), semanticObject.getBeat());
		feeder.accept(grammarAccess.getTimeSignatureAccess().getBeatTypeEIntParserRuleCall_3_0(), semanticObject.getBeatType());
		feeder.finish();
	}
	
	
}
